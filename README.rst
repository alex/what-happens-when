Что происходит, когда...
====================

Этот репозиторий - попытка ответить на давний вопрос с собеседований: "Что
происходит, когда вы вводите google.com в адресной строке браузера и нажимаете
Enter?"

Здесь, вместо обычной истории, мы попытаемся ответить на этот вопрос
с максимальной детализацией. Ничего не упускаем.

Это коллаборативный процесс, так что присоединяйтесь и попытайтесь помочь! Здесь
много деталей, которые не хватает, и они ждут, пока вы их добавите! Пожалуйста,
отправьте нам запрос на внесение изменений (pull request)!

Все это распространяется под условиями лицензии `Creative Commons Zero`_.

Читать на других языках: `简体中文`_ (упрощенный китайский), `日本語`_ (японский), `한국어`_
(корейский) и `Spanish`_. ПРИМЕЧАНИЕ: эти тексты не были проверены сотрудниками
проекта alex/what-happens-when.

Содержание
====================

.. contents::
   :backlinks: none
   :local:

Нажата клавиша "g"
----------------------
Следующие разделы объясняют физические действия на клавиатуре и прерывания ОС.
Когда вы нажимаете клавишу "g", браузер получает событие, и начинают работать
функции автозаполнения.
В зависимости от алгоритма вашего браузера и того, находитесь ли вы в
режиме приватности или нет, вам будут предложены различные варианты в выпадающем
списке под адресной строкой URL. Большинство этих алгоритмов сортируют и
приоритезируют результаты на основе истории поиска, закладок, файлов cookie и
популярных запросов из интернета в целом. По мере ввода "google.com" выполняется
множество блоков кода, и предложения будут уточняться с каждым нажатием клавиши.
Он даже может предложить "google.com" до того, как вы закончите вводить его.

Клавиша "Enter" нажимается до упора
---------------------------

Чтобы выбрать нулевую точку, давайте выберем клавишу Enter на клавиатуре, когда
она достигает нижнего предела своего хода. В этот момент срабатывает
электрическая цепь, специфичная для клавиши Enter (непосредственно или
капацитивно). Это позволяет небольшому количеству тока пройти в логические
схемы клавиатуры, которые сканируют состояние каждого переключателя клавиши,
убирают электрический шум от быстрого многократного замыкания переключателя
и преобразуют его в целочисленный код, в данном случае 13. Контроллер клавиатуры
затем кодирует ключевой код для передачи на компьютер.
Теперь это практически всегда происходит через Universal Serial Bus (USB)
или Bluetooth-соединение, но исторически это происходило через соединения
PS/2 или ADB.

*В случае клавиатуры USB:*

- USB-схема клавиатуры питается от 5-вольтовой подачи, предоставляемой через
  контроллер USB хоста компьютера через контакт 1.

- Сгенерированный ключевой код хранится в памяти внутренней схемы клавиатуры
  в регистре, называемом "endpoint".

- Контроллер USB хоста sond`endpoint` каждые ~10 мс (минимальное значение,
  указанное клавиатурой), чтобы получить хранящееся на нем значение ключевого
  кода.

- Это значение идет в USB SIE (Serial Interface Engine) для преобразования в
  один или несколько USB-пакетов, следующих протоколу USB на низком уровне.

- Эти пакеты отправляются по дифференциальному электрическому сигналу через
  контакты D+ и D- (серединные 2) с максимальной скоростью 1,5 Мб/с, так как
  устройство HID (Human Interface Device) всегда объявляется "устройством
  низкой скорости" (соответствие USB 2.0).

- Этот последовательный сигнал затем декодируется контроллером USB хоста
  компьютера и интерпретируется драйвером универсальной клавиатуры устройства
  HID компьютера. Значение клавиши затем передается в аппаратный слой абстракции
  операционной системы.

*В случае виртуальной клавиатуры (как в устройствах с сенсорным экраном):*

- Когда пользователь прикладывает палец к современному ёмкостному сенсорному
  экрану, небольшое количество тока переходит на палец. Это завершает
  цепь через электростатическое поле проводящего слоя и вызывает падение
  напряжения в этой точке на экране. Затем контроллер экрана
  генерирует прерывание, сообщая координаты нажатия клавиши.

- Затем мобильная ОС уведомляет текущее приложение о событии нажатия
  в одном из его элементов пользовательского интерфейса (которым сейчас
  является приложение виртуальной клавиатуры).

- Виртуальная клавиатура теперь может генерировать программное прерывание для
  отправки сообщения "клавиша нажата" обратно в ОС.

- Это прерывание уведомляет текущее приложение о событии "клавиша нажата".


Прерывание срабатывает [НЕ для USB-клавиатур]
-----------------------------------------------------

Клавиатура отправляет сигналы на своей линии запроса прерывания (IRQ), которая
сопоставляется с "вектором прерывания" (целым числом) контроллером прерывания.
Центральный процессор (CPU) использует "Таблицу дескрипторов прерываний" (IDT)
для сопоставления векторов прерывания с функциями ("обработчиками прерываний"),
которые предоставляются ядром. Когда происходит прерывание, CPU индексирует IDT
с вектором прерывания и выполняет соответствующий обработчик. Таким образом,
происходит вход в ядро.

(На Windows) Отправляется сообщение "WM_KEYDOWN" в приложение
--------------------------------------------------------

Транспортный протокол HID передает событие нажатия клавиши драйверу "KBDHID.sys",
который преобразует использование HID в скан-код. В данном случае скан-код -
"VK_RETURN" ("0x0D"). Драйвер "KBDHID.sys" взаимодействует с драйвером
клавиатурного класса "KBDCLASS.sys". Этот драйвер отвечает за обработку всех
вводов с клавиатуры и клавишей-клавиатурой в безопасном режиме. Затем происходит
вызов "Win32K.sys" (после, возможно, передачи сообщения через сторонние
фильтры клавиатуры, установленные сторонними разработчиками). Все это происходит
в режиме ядра.

"Win32K.sys" определяет, какое окно является активным окном с помощью
API "GetForegroundWindow()". Это API предоставляет дескриптор окна строки URL
браузера. Затем "основной цикл сообщений" Windows вызывает
"SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam)". "lParam" - это битовая маска,
которая указывает дополнительную информацию о нажатии клавиши: количество
повторений (в данном случае 0), фактический скан-код (может зависеть от
OEM, но обычно не меняется для "VK_RETURN"), были ли нажаты расширенные клавиши
(например, Alt, Shift, Ctrl) (их не было) и некоторые другие состояния.

API "SendMessage" Windows - это простая функция, которая
добавляет сообщение в очередь для определенного дескриптора окна ("hWnd").
Затем основная функция обработки сообщений (называемая "WindowProc"), назначенная
"hWnd", вызывается для обработки каждого сообщения в очереди.

Активное окно ("hWnd") фактически является элементом управления редактирования,
и "WindowProc" в данном случае имеет обработчик сообщений "WM_KEYDOWN". Этот код
смотрит в третий параметр, который был передан в "SendMessage" ("wParam"), и, так
как это "VK_RETURN", знает, что пользователь нажал клавишу ENTER.

(На OS X) Отправляется событие "KeyDown" NSEvent в приложение
--------------------------------------------------

Сигнал прерывания инициирует событие прерывания в драйвере клавиатуры I/O Kit kext.
Драйвер преобразует сигнал в код клавиши, который передается процессу "WindowServer"
ОС X. Следовательно, "WindowServer" отправляет событие в соответствующие
(например, активные или слушающие) приложения через их Mach-порт, где оно помещается
в очередь событий. События затем могут быть прочитаны из этой очереди потоками с
достаточными привилегиями с помощью функции "mach_ipc_dispatch". Это обычно
происходит через главный цикл событий "NSApplication" с помощью события "NSEvent"
с типом "KeyDown".

(На GNU/Linux) сервер Xorg прослушивает коды клавиш
---------------------------------------------------

Когда используется графический сервер "X", "X" будет использовать общий драйвер
событий "evdev" для получения нажатия клавиши. Перенаправление кодов клавиш
в скан-коды выполняется с помощью специальных карт клавиш и правил, связанных
с сервером "X". Когда отображение скан-кода нажатой клавиши завершено,
"X" сервер отправляет символ в "менеджер окон" (DWM, metacity, i3 и так далее),
чтобы "менеджер окон" затем отправил символ в активное окно. Графический API
окна, которое получает символ, выводит соответствующий символ шрифта в активное
поле.

Анализ URL
---------

* Теперь браузер содержит следующую информацию в URL (единообразный
  идентификатор ресурса):

    - Протокол "http"
        Использование "Протокола передачи гипертекста"

    - Ресурс "/"
        Получение основной (главной) страницы

Это URL или поисковый запрос?
-------------------------------

Когда не указан протокол или действительное имя домена, браузер переходит к
передаче текста, указанного в адресной строке, в поисковую систему по умолчанию.
Во многих случаях URL имеет специальный текст, добавленный к нему, чтобы
уведомить поисковую систему, что он был введен в адресную строку браузера.

Преобразование символов Unicode, не входящих в ASCII, в имени хоста
------------------------------------------------

* Браузер проверяет имя хоста на наличие символов, не входящих в "a-z",
  "A-Z", "0-9", "-", или ".".
* Поскольку имя хоста - "google.com", здесь их не будет, но если бы они были,
  браузер применил бы кодирование "Punycode" к части имени хоста URL.

Проверка списка HSTS
--------------------
* Браузер проверяет свой список "предварительно загруженных HSTS (HTTP Strict
  Transport Security)". Это список веб-сайтов, которые запросили быть связанными
  только через HTTPS.
* Если веб-сайт есть в списке, браузер отправляет запрос через HTTPS, а не через HTTP.
  (Обратите внимание, что веб-сайт все равно может использовать политику HSTS,
  *не* находясь в списке HSTS. Первый HTTP-запрос на веб-сайт пользователем будет
  получать ответ с просьбой отправлять только запросы HTTPS. Однако этот
  единственный HTTP-запрос может потенциально сделать пользователя уязвимым для
  `атаки снижения`_, поэтому список HSTS включен в современные веб-браузеры.)

Поиск DNS
----------

* Браузер проверяет, есть ли домен в его кэше DNS (чтобы увидеть кэш DNS
  в Chrome, перейдите по ссылке `chrome://net-internals/#dns <chrome://net-internals/#dns>`_).
* Если не найдено, браузер вызывает функцию библиотеки ``gethostbyname``
  (варьируется в зависимости от операционной системы) для выполнения поиска.
* ``gethostbyname`` проверяет, может ли имя хоста быть разрешено путем обращения к
  локальному файлу "hosts" (местоположение которого `варьируется в зависимости от
  операционной системы`_), прежде чем пытаться разрешить имя хоста через DNS.
* Если ``gethostbyname`` не имеет его в кэше и не может найти его в файле "hosts",
  то он отправляет запрос на DNS-сервер, настроенный в сетевом стеке. Обычно это
  локальный маршрутизатор или кэширующий DNS-сервер поставщика услуг.
* Если DNS-сервер находится в том же подсети, сетевая библиотека следует
  процессу "ARP", описанному ниже, для DNS-сервера.
* Если DNS-сервер находится в другой подсети, сетевая библиотека следует
  процессу "ARP", описанному ниже, для IP-адреса шлюза по умолчанию.

Процесс ARP
-----------

Для отправки широковещательного ARP (протокола разрешения адресов) библиотеке
сетевого стека требуется IP-адрес цели для поиска. Также требуется знать MAC-адрес
интерфейса, который будет использоваться для отправки широковещательного ARP.

Сначала проверяется кеш ARP на наличие записи ARP для целевого IP-адреса.
Если запись есть в кеше, функция библиотеки возвращает результат: IP-адрес цели = MAC.

Если записи нет в кеше ARP:

* Выполняется поиск таблицы маршрутов, чтобы узнать, находится ли IP-адрес цели
  на какой-либо из подсетей в локальной таблице маршрутов. Если да, библиотека
  использует интерфейс, связанный с этой подсетью. Если нет, библиотека использует
  интерфейс, который имеет подсеть нашего шлюза по умолчанию.

* Выполняется поиск MAC-адреса выбранного сетевого интерфейса.

* Сетевая библиотека отправляет ARP-запрос уровня 2 (уровень канала данных
  `модели OSI`_):

``Запрос ARP``::

    MAC-адрес отправителя: interface:mac:address:here
    IP-адрес отправителя: interface.ip.goes.here
    MAC-адрес цели: FF:FF:FF:FF:FF:FF (Широковещательный)
    IP-адрес цели: target.ip.goes.here

В зависимости от типа оборудования между компьютером и маршрутизатором:

Подключение напрямую:

* Если компьютер напрямую подключен к маршрутизатору, маршрутизатор
  отвечает на ARP-ответ (см. ниже).

Хаб:

* Если компьютер подключен к хабу, хаб будет транслировать ARP-запрос на
  все остальные порты. Если маршрутизатор подключен к той же "проволоке",
  он ответит на ARP-ответ (см. ниже).

Коммутатор:

* Если компьютер подключен к коммутатору, коммутатор проверит свою локальную
  таблицу CAM/MAC, чтобы узнать, какой порт имеет MAC-адрес, который мы ищем.
  Если в коммутаторе нет записи для MAC-адреса, он переправит ARP-запрос
  на все остальные порты.

* Если в коммутаторе есть запись в таблице MAC/CAM, он отправит ARP-запрос
  на порт, на котором находится MAC-адрес, который мы ищем.

* Если маршрутизатор находится на той же "проволоке", он ответит на ARP-ответ
  (см. ниже).

``ARP-ответ``::

    MAC-адрес отправителя: target:mac:address:here
    IP-адрес отправителя: target.ip.goes.here
    MAC-адрес цели: interface:mac:address:here
    IP-адрес цели: interface.ip.goes.here

Теперь, когда сетевой стек имеет IP-адрес либо нашего DNS-сервера, либо
шлюза по умолчанию, он может продолжить процесс DNS:

* Клиент DNS устанавливает сокет к UDP-порту 53 на DNS-сервере, используя
  исходный порт выше 1023.
* Если размер ответа слишком большой, вместо этого используется TCP.
* Если локальный/ISP DNS-сервер его не имеет, то запрашивается рекурсивный поиск,
  и этот запрос распространяется вверх по списку DNS-серверов, пока не будет достигнут
  SOA, и если найден ответ, он возвращается.


Открытие сокета
-------------------
После того, как браузер получает IP-адрес сервера назначения, он берет этот адрес и
указанный номер порта из URL (протокол HTTP использует порт по умолчанию 80, а HTTPS
порт 443) и вызывает функцию системной библиотеки с именем ``socket`` и запрос на
TCP-сокет - ``AF_INET/AF_INET6`` и ``SOCK_STREAM``.

* Этот запрос сначала передается на уровень транспортного уровня, где создается
  TCP-сегмент. Назначен номер порта назначения в заголовке, и выбран номер порта
  источника из диапазона динамических портов ядра (ip_local_port_range в Linux).
* Этот сегмент передается на сетевой уровень, который оборачивает его в дополнительный
  IP-заголовок. IP-адрес сервера назначения, а также IP-адрес текущей машины, вставляется
  для создания пакета.
* Пакет затем достигает уровня сетевого соединения. Заголовок кадра добавляется,
  включая MAC-адрес сетевого адаптера машины и MAC-адрес шлюза (локального маршрутизатора).
  Как и ранее, если ядро не знает MAC-адрес шлюза, оно должно транслировать ARP-запрос,
  чтобы найти его.

На этом этапе пакет готов к передаче через:

* `Ethernet`_
* `WiFi`_
* `Сеть сотовых данных`_

Для большинства домашних или малых предприятий Интернет-подключений пакет будет
передаваться с вашего компьютера, возможно, через локальную сеть, а затем через
модем (MOdulator/DEModulator), который преобразует цифровые 1 и 0 в аналоговый
сигнал, подходящий для передачи по телефонным, кабельным или беспроводным телефонным
соединениям. С другой стороны соединения находится еще один модем, который преобразует
аналоговый сигнал обратно в цифровые данные, которые будут обрабатываться следующим
`сетевым узлом`_, где адреса откуда и куда будут анализироваться дальше.

Большинство крупных предприятий и некоторые новые домашние подключения будут
иметь оптоволоконные или прямые Ethernet-подключения, в этом случае данные остаются
цифровыми и передаются непосредственно следующему `сетевому узлу`_ для обработки.

В конечном итоге пакет дойдет до маршрутизатора, управляющего локальной подсетью. Оттуда
он продолжит движение к граничным маршрутизаторам автономной системы (AS), другим AS и,
наконец, к серверу назначения. Каждый маршрутизатор на пути извлекает адрес назначения
из IP-заголовка и маршрутизирует его к соответствующему следующему узлу. Поле время
жизни (TTL) в IP-заголовке уменьшается на один для каждого маршрутизатора, который
проходит. Пакет будет отброшен, если поле TTL достигнет нуля или если текущий
маршрутизатор не имеет места в своей очереди (возможно из-за сетевой перегрузки).

Эта отправка и получение происходит несколько раз, следуя потоку соединения TCP:

* Клиент выбирает начальный порядковый номер (ISN) и отправляет пакет на
  сервер с установленным битом SYN, чтобы указать, что он устанавливает ISN.
* Сервер получает SYN, и если находится в согласованном настроении:
   * Сервер выбирает свой собственный начальный порядковый номер
   * Сервер устанавливает SYN, чтобы указать, что он выбирает свой ISN
   * Сервер копирует (ISN клиента + 1) в свое поле ACK и добавляет флаг ACK,
     чтобы указать, что он подтверждает получение первого пакета
* Клиент подтверждает соединение, отправляя пакет:
   * Увеличивает свой собственный порядковый номер
   * Увеличивает номер подтверждения получателя
   * Устанавливает поле ACK
* Данные передаются следующим образом:
   * Как только одна сторона отправляет N байт данных, она увеличивает свой SEQ на это
     число
   * Когда другая сторона подтверждает получение этого пакета (или строки пакетов), она
     отправляет пакет ACK с значением ACK, равным последнему полученному порядковому номеру
     от другой стороны
* Для закрытия соединения:
   * Закрывающая сторона отправляет пакет FIN
   * Другая сторона подтверждает пакет FIN и отправляет свой собственный FIN
   * Закрывающая сторона подтверждает пакет FIN от другой стороны с помощью ACK

Рукопожатие TLS
-------------
* Клиентский компьютер отправляет сообщение ``ClientHello`` на сервер с указанием своей
  версии протокола безопасности транспортного уровня (TLS), списка алгоритмов шифрования
  и доступных методов сжатия.

* Сервер отвечает клиенту сообщением ``ServerHello`` с указанием версии TLS, выбранного
  алгоритма шифрования, выбранных методов сжатия и открытого сертификата сервера,
  подписанного удостоверяющим центром (CA, Certificate Authority). Сертификат содержит
  открытый ключ, который будет использоваться клиентом для шифрования остатка рукопожатия,
  пока не будет достигнуто соглашение о симметричном ключе.

* Клиент проверяет цифровой сертификат сервера на предмет соответствия своему списку
  доверенных Центров сертификации. Если доверие может быть установлено на основе
  CA, клиент генерирует строку псевдослучайных байтов и шифрует ее открытым ключом
  сервера. Эти случайные байты могут быть использованы для определения симметричного ключа.

* Сервер расшифровывает случайные байты с использованием своего закрытого ключа и
  использует их для создания собственной копии симметричного ключа.

* Клиент отправляет сообщение ``Finished`` на сервер, шифруя хэш передачи до этого
  момента с использованием симметрического ключа.

* Сервер создает собственный хэш, а затем расшифровывает хэш, отправленный клиентом,
  чтобы проверить его соответствие. Если соответствие есть, он отправляет собственное
  сообщение ``Finished`` клиенту, также зашифрованное симметрическим ключом.

* С этого момента сеанс TLS передает данные приложения (HTTP), зашифрованные согласованным
  симметричным ключом.

Если пакет утерян
----------------------

Иногда, из-за сетевой перегрузки или нестабильных аппаратных соединений, пакеты TLS могут
быть утеряны до достижения конечного пункта назначения. Отправитель должен решить, как
реагировать. Алгоритм для этого называется `управлением перегрузкой TCP`_. Это различается
в зависимости от отправителя; наиболее распространенными алгоритмами являются `cubic`_ на
новых операционных системах и `New Reno`_ на почти всех остальных.

* Клиент выбирает `окно перегрузки`_ на основе `максимального размера сегмента`_
  (MSS) соединения.
* Для каждого подтвержденного пакета окно удваивается до достижения порога
  'медленного старта'. В некоторых реализациях этот порог является адаптивным.
* После достижения порога медленного старта окно увеличивается аддитивно для каждого
  подтвержденного пакета. Если пакет утерян, окно уменьшается экспоненциально до
  подтверждения следующего пакета.

Протокол HTTP
-------------

Если используется веб-браузер, написанный Google, вместо отправки HTTP-запроса для получения
страницы, он отправит запрос для попытки договориться с сервером о "обновлении" с HTTP на
протокол SPDY.

Если клиент использует протокол HTTP и не поддерживает SPDY, он отправляет запрос серверу
в следующем формате::

    GET / HTTP/1.1
    Host: google.com
    Connection: close
    [другие заголовки]

где ``[другие заголовки]`` относится к серии пар ключ-значение, отформатированных в
соответствии с HTTP-спецификацией и разделенных одиночными символами новой строки.
(Это предполагает, что используемый веб-браузер не содержит ошибок, нарушающих
спецификацию HTTP. Это также предполагает, что веб-браузер использует ``HTTP/1.1``,
в противном случае в запрос может не включаться заголовок ``Host``, и версия,
указанная в запросе ``GET``, будет либо ``HTTP/1.0``, либо ``HTTP/0.9``.)

HTTP/1.1 определяет опцию соединения "close" для отправителя, чтобы сигнализировать,
что соединение будет закрыто после завершения ответа. Например,

    Connection: close

Приложения HTTP/1.1, не поддерживающие постоянные соединения, ДОЛЖНЫ включать
опцию соединения "close" в каждое сообщение.

После отправки запроса и заголовков веб-браузер отправляет одну пустую строку серверу,
указывая, что содержание запроса завершено.

Сервер отвечает кодом ответа, обозначающим статус запроса, и отвечает ответом следующего вида::

    200 OK
    [заголовки ответа]

За которыми следует одна пустая строка, а затем отправляется полезная нагрузка HTML-контента
``www.google.com``. Затем сервер может либо закрыть соединение, либо, если заголовки,
отправленные клиентом, запрашивают это, оставить соединение открытым для последующих запросов.

Если HTTP-заголовки, отправленные веб-браузером, содержат достаточную информацию для веб-сервера,
чтобы определить, была ли версия файла, закешированная веб-браузером, изменена с момента
последнего запроса (например, если веб-браузер включил заголовок ``ETag``), сервер может
вместо этого ответить запросом следующего вида::

    304 Not Modified
    [заголовки ответа]


и без полезной нагрузки, и веб-браузер вместо этого получает HTML из своего кэша.

После разбора HTML веб-браузер (и сервер) повторяет этот процесс для каждого ресурса (изображение, CSS, favicon.ico и др.), на которые ссылается HTML-страница, за исключением случаев, когда вместо ``GET / HTTP/1.1`` запрос будет выглядеть как ``GET /$(URL относительно www.google.com) HTTP/1.1``.

Если HTML ссылается на ресурс на другом домене, отличном от ``www.google.com``, веб-браузер возвращается к этапам, связанным с разрешением этого другого домена, и выполняет все шаги до данного момента для этого домена. Заголовок ``Host`` в запросе будет установлен на соответствующее имя сервера, а не ``google.com``.

Обработка HTTP-запроса сервером
--------------------------
Сервер HTTPD (HTTP Daemon) обрабатывает запросы/ответы с серверной стороны. Самыми распространенными серверами HTTPD являются Apache или nginx для Linux и IIS для Windows.

* Сервер HTTPD (HTTP Daemon) получает запрос.
* Сервер разбивает запрос на следующие параметры:
   * Метод HTTP-запроса (``GET``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, ``DELETE``, ``CONNECT``, ``OPTIONS`` или ``TRACE``). В случае, если URL введен непосредственно в адресную строку, метод будет ``GET``.
   * Домен, в данном случае - google.com.
   * Запрошенный путь/страница, в данном случае - / (поскольку конкретный путь/страница не был запрошен, / - это путь по умолчанию).
* Сервер проверяет наличие виртуального хоста на сервере, соответствующего google.com.
* Сервер проверяет, что google.com может принимать запросы GET.
* Сервер проверяет, что клиент может использовать этот метод (по IP, аутентификации и др.).
* Если на сервере установлен модуль переписывания (например, mod_rewrite для Apache или URL Rewrite для IIS), сервер пытается сопоставить запрос с одним из настроенных правил. Если найдено совпадающее правило, сервер использует его для переписывания запроса.
* Сервер идет извлекать содержимое, соответствующее запросу; в нашем случае он вернется к индексному файлу, так как "/" - это главный файл (в некоторых случаях это можно переопределить, но это наиболее распространенный метод).
* Сервер разбирает файл в соответствии с обработчиком. Если Google использует PHP, сервер использует PHP для интерпретации индексного файла и передачи вывода клиенту.

За кулисами браузера
----------------------------------

Как только сервер предоставляет ресурсы (HTML, CSS, JS, изображения и т. д.) браузеру, происходит следующий процесс:

* Разбор - HTML, CSS, JS
* Рендеринг - Создание дерева DOM → Дерево рендеринга → Оформление дерева рендеринга → Отрисовка дерева рендеринга

Браузер
-------

Функциональность браузера заключается в представлении выбранного вами веб-ресурса, запрашивая его с сервера и отображая его в окне браузера. Ресурс обычно представляет собой HTML-документ, но также может быть PDF, изображением или другим типом содержимого. Местоположение ресурса указывается пользователем с использованием URI (Uniform Resource Identifier).

Способ интерпретации и отображения HTML-файлов в браузере указан в спецификациях HTML и CSS. Эти спецификации поддерживаются организацией W3C (World Wide Web Consortium), которая является стандартизирующей организацией для веба.

Интерфейс пользователя браузера имеет много общего между собой. Среди общих элементов пользовательского интерфейса есть:

* Адресная строка для вставки URI
* Кнопки "назад" и "вперед"
* Опции добавления в закладки
* Кнопки "обновить" и "остановить" для обновления или остановки загрузки текущих документов
* Кнопка "домой", которая переносит вас на вашу домашнюю страницу

**Высокоуровневая структура браузера**

Компоненты браузеров включают:

* **Пользовательский интерфейс:** В пользовательском интерфейсе есть адресная строка, кнопки "назад" и "вперед", меню закладок и т. д. Вся часть отображения браузера, кроме окна, где отображается запрашиваемая страница.
* **Браузерный движок:** Браузерный движок осуществляет взаимодействие между интерфейсом пользователя и рендеринговым движком.
* **Рендеринговый движок:** Рендеринговый движок отвечает за отображение запрошенного контента. Например, если запрошенный контент - это HTML, рендеринговый движок анализирует HTML и CSS и отображает разобранный контент на экране.
* **Сетевой слой:** Сетевой слой обрабатывает сетевые вызовы, такие как HTTP-запросы, с использованием различных реализаций для разных платформ, предоставляя платформонезависимый интерфейс.
* **Бэкэнд пользовательского интерфейса:** Бэкэнд пользовательского интерфейса используется для отображения основных элементов интерфейса, таких как комбинированные окна и окна. Этот бэкэнд предоставляет универсальный интерфейс, который не является зависимым от конкретной платформы. Внутри используются методы пользовательского интерфейса операционной системы.
* **Движок JavaScript:** Движок JavaScript используется для анализа и выполнения кода JavaScript.
* **Хранилище данных:** Хранилище данных - это уровень хранения. Браузеру может понадобиться сохранять различные данные локально, такие как файлы cookie. Браузеры также поддерживают механизмы хранения, такие как localStorage, IndexedDB, WebSQL и FileSystem.

Разбор HTML
------------

Рендеринговый движок начинает получать содержимое запрошенного документа из сетевого слоя. Обычно это происходит порциями размером 8 КБ.

Основная задача парсера HTML - разобрать разметку HTML в дерево разбора.

Результат разбора (``дерево разбора``) представляет собой дерево узлов элементов DOM и атрибутов. DOM - сокращение от Document Object Model. Это объектное представление HTML-документа и интерфейс элементов HTML для внешнего мира, такого как JavaScript. Корень дерева - это объект "Document". Перед любыми манипуляциями через сценарий DOM имеет практически однозначное соответствие с разметкой.

**Алгоритм разбора**

HTML нельзя разобрать с помощью обычных верхних или нижних синтаксических анализаторов.

Причины следующие:

* Прощающий характер языка.
* Факт того, что браузеры традиционно допускают ошибки для поддержки хорошо известных случаев недопустимого HTML.
* Процесс разбора реентерабелен. В отличие от других языков, исходный код во время разбора обычно не меняется, но в HTML динамический код (например, элементы script, содержащие вызовы ``document.write()``) могут добавлять дополнительные токены, так что процесс разбора на самом деле изменяет входные данные.

Невозможность использовать обычные техники разбора заставляет браузер использовать специальный парсер для разбора HTML. Алгоритм разбора подробно описан в спецификации HTML5.

Алгоритм включает в себя два этапа: токенизацию и построение дерева.

**Действия при завершении разбора**

Браузер начинает загружать внешние ресурсы, связанные с страницей (CSS, изображения, файлы JavaScript и т. д.).

На этом этапе браузер отмечает документ как интерактивный и начинает разбирать скрипты, находящиеся в "отложенном" режиме, то есть тех, которые должны выполняться после разбора документа. Состояние документа устанавливается как "полностью загружен", и генерируется событие "загрузки".

Следует отметить, что на HTML-странице никогда не происходит ошибка "Недопустимый синтаксис". Браузеры исправляют любой недопустимый контент и продолжают выполнение.

Интерпретация CSS
------------------

* Разбор файлов CSS, содержимого тега ``<style>`` и значений атрибута ``style`` с использованием "Лексической и синтаксической грамматики CSS"_
* Каждый файл CSS разбирается в объект ``StyleSheet``, где каждый объект содержит правила CSS с селекторами и объекты, соответствующие грамматике CSS.
* Парсер CSS может быть сверху вниз или снизу вверх при использовании конкретного генератора парсера.

Отображение страницы
--------------

* Создание "Дерева кадров" или "Дерева отрисовки", перебирая узлы DOM и вычисляя значения стилей CSS для каждого узла.
* Расчет предпочтительной ширины каждого узла в "Дереве кадров" снизу вверх, путем сложения предпочтительной ширины дочерних узлов и горизонтальных полей, границ и отступов узла.
* Расчет фактической ширины каждого узла сверху вниз, выделяя доступную ширину каждого узла его детям.
* Расчет высоты каждого узла снизу вверх с применением переноса текста и сложения высоты дочерних узлов и вертикальных полей, границ и отступов узла.
* Расчет координат каждого узла с использованием вышеуказанной информации.
* Более сложные шаги предпринимаются, когда элементы "выравниваются", позиционируются "абсолютно" или "относительно" или используются другие сложные функции. Дополнительные сведения см. на сайтах http://dev.w3.org/csswg/css2/ и http://www.w3.org/Style/CSS/current-work.
* Создание слоев, чтобы описать части страницы, которые можно анимировать вместе без повторного растеризации. Каждому объекту кадра/отрисовки назначается слой.
* Текстуры выделяются для каждого слоя на странице.
* Объекты кадра/отрисовки для каждого слоя перебираются, и выполняются команды рисования для соответствующего слоя. Это может быть растеризовано на процессоре или отрисовано непосредственно на GPU с использованием D2D/SkiaGL.
* Все вышеперечисленные шаги могут использовать ранее вычисленные значения из предыдущего раза, когда веб-страница была отрисована, чтобы изменения требовали меньше работы.
* Слои страницы отправляются в процесс компоновки, где они объединяются с слоями другого видимого контента, такого как элементы интерфейса браузера, iframe и панели дополнений.
* Вычисляются окончательные позиции слоев, и выполняются команды композиции через Direct3D/OpenGL. Буфер(ы) команд GPU сбрасываются на GPU для асинхронной отрисовки, и кадр отправляется на сервер окон.

Графическая отрисовка с использованием GPU
-------------

* Во время процесса отрисовки графические вычисления могут использовать общепроцессорное "ЦП" или графический процессор "GPU".

* При использовании "GPU" для вычислений графической отрисовки программное обеспечение графики разбивает задачу на несколько частей, так что оно может воспользоваться массовым параллелизмом "GPU" для выполнения вычислений с плавающей точкой, необходимых для процесса отрисовки.

Сервер окон
-------------

Пост-отрисовка и выполнение по инициативе пользователя
-----------------------------------------

После завершения отрисовки браузер выполняет код JavaScript как результат какого-либо механизма синхронизации (например, анимации Google Doodle) или пользовательского взаимодействия (например, ввод запроса в поле поиска и получение предложений). Плагины, такие как Flash или Java, также могут выполняться, хотя не на главной странице Google. Скрипты могут вызывать дополнительные сетевые запросы, а также модифицировать страницу или ее макет, вызывая еще один раунд отрисовки и рисовки страницы.

.. _`Creative Commons Zero`: https://creativecommons.org/publicdomain/zero/1.0/
.. _`"CSS lexical and syntax grammar"`: http://www.w3.org/TR/CSS2/grammar.html
.. _`Punycode`: https://en.wikipedia.org/wiki/Punycode
.. _`Ethernet`: http://en.wikipedia.org/wiki/IEEE_802.3
.. _`WiFi`: https://en.wikipedia.org/wiki/IEEE_802.11
.. _`Cellular data network`: https://en.wikipedia.org/wiki/Cellular_data_communication_protocol
.. _`analog-to-digital converter`: https://en.wikipedia.org/wiki/Analog-to-digital_converter
.. _`network node`: https://en.wikipedia.org/wiki/Computer_network#Network_nodes
.. _`TCP congestion control`: https://en.wikipedia.org/wiki/TCP_congestion_control
.. _`cubic`: https://en.wikipedia.org/wiki/CUBIC_TCP
.. _`New Reno`: https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_New_Reno
.. _`congestion window`: https://en.wikipedia.org/wiki/TCP_congestion_control#Congestion_window
.. _`maximum segment size`: https://en.wikipedia.org/wiki/Maximum_segment_size
.. _`varies by OS` : https://en.wikipedia.org/wiki/Hosts_%28file%29#Location_in_the_file_system
.. _`简体中文`: https://github.com/skyline75489/what-happens-when-zh_CN
.. _`한국어`: https://github.com/SantonyChoi/what-happens-when-KR
.. _`日本語`: https://github.com/tettttsuo/what-happens-when-JA
.. _`downgrade attack`: http://en.wikipedia.org/wiki/SSL_stripping
.. _`OSI Model`: https://en.wikipedia.org/wiki/OSI_model
.. _`WebSockets`: https://en.wikipedia.org/wiki/WebSocket
.. _`HTML5 WebSocket API`: https://www.w3.org/TR/websockets/
.. _`HTTP/2`: https://en.wikipedia.org/wiki/HTTP/2
.. _`CDN (Content Delivery Network)`: https://en.wikipedia.org/wiki/Content_delivery_network
.. _`HTML5`: https://www.w3.org/TR/html5/
.. _`YouTube player API`: https://developers.google.com/youtube/js_api_reference
.. _`HTML5 History API`: https://developer.mozilla.org/en-US/docs/Web/API/History_API
.. _`File API`: https://developer.mozilla.org/en-US/docs/Web/API/File
.. _`FileReader API`: https://developer.mozilla.org/en-US/docs/Web/API/FileReader
.. _`indexedDB API`: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
.. _`Web Storage API`: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API
.. _`Cookies`: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
.. _`WebSockets API`: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API
.. _`HTML5 Web Workers API`: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API
.. _`WebRTC`: https://webrtc.org/
.. _`HTML5 Audio/Video API`: https://developer.mozilla.org/en-US/docs/Web/API/HTML5_Audio
.. _`IIS`: https://www.iis.net/
.. _`mod_rewrite`: https://httpd.apache.org/docs/current/mod/mod_rewrite.html
.. _`URL Rewrite`: http://www.iis.net/learn/extensions/url-rewrite-module/url-rewrite-module-configuration-reference
.. _`Document Object Model`: https://en.wikipedia.org/wiki/Document_Object_Model
.. _`OpenGL`: https://en.wikipedia.org/wiki/OpenGL
.. _`D3D`: https://en.wikipedia.org/wiki/Direct3D
.. _`Favicon.ico`: https://en.wikipedia.org/wiki/Favicon
.. _`Uniform Resource Identifier`: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier
